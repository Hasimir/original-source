// dwhtmdm.cpp is the code for dcl HTM DITA map support, JHG
// Copyright (c) 2007 by Omni Systems, Inc.  All rights reserved.

#include "dcappl.h"
#include "dcctlg.h"
#include "dclist.h"
#include "dcfili.h"
#include "dctxfx.h"
#include "dcfmtr.h"
#include "dcfilp.h"
#include "dcini.h"
#include "dcmacr.h"
#include "dwhtm.h"
#include "dwhtmfl.h"


// variables

bool HXMwr::UseDITAMapID = true;
char *HXMwr::DITAMapID = NULL;
char *HXMwr::DITAMapTitle = NULL;
char *HXMwr::DITAMapTitleAlt = NULL;
char *HXMwr::DITAMapHead = NULL;
char *HXMwr::DITAMapHeadAlt = NULL;

char *HXMwr::DITAMapBase = NULL;
char *HXMwr::DITAMapFileName = NULL;
bool HXMwr::MapTopicmeta = true;
bool HXMwr::MapTopicID = true;
bool HXMwr::UseAltMapTitle = false;

DCvlist HXMwr::DITAMapVals;    // DITAMapVal indexed by topicnum, all toc
DCvlist HXMwr::DITARelVals;    // DITAMapVal indexed by topicnum, topic only
dmapprop *HXMwr::DITAMapVal = NULL;
DCnlist *HXMwr::DITARefAttrs = NULL;
DCnlist *HXMwr::DITARefAttrNames = NULL;
long HXMwr::DITARefCount = 0;

bool HXMwr::WriteDitamaps = true;
bool HXMwr::MapBookTopics = true;
bool HXMwr::MapBookRelTable = true;

unc HXMwr::DITABookmapType = 'D';
char *HXMwr::DITABookTitle = NULL;
char *HXMwr::DITABookSubtitle = NULL;
char *HXMwr::DITABookLibrary = NULL;
char *HXMwr::DITABookMeta = NULL;


// functions

void HXMwr::WriteDITAMap(HTMwfile *wf)
{
	// write out chapter filename.ditamap using DITAMapVals
	if (!DITAMapVal)
		return;

	if (!WriteDitamaps)
		DITAFullMapDiv = wf->NewDiv();

	// DITAMapBase has base name to use
	DITAMapFileName = NewName(DITAMapBase, strlen(DITAMapBase) + 9);
	strcat(DITAMapFileName, ".ditamap");
	wf->ReopenFile(DITAMapFileName);
	wf->putXML(HTMwr::XMLEncoding, HTMwr::XMLVer);

	long tnum = DTopicTypes->getitem("map");

	tagset *ttags = (tagset *) DTagSets->find(tnum);
	if (!ttags)
		ttags = DMapTags;

	char *troot = ttags->names->find(1);
	if (!troot)
		troot = "map";

	HTMwr::XMLRoot = troot;
	wf->putDT(troot, ttags->dtype, ttags->dtd, false);  

#if 0
	XMLRoot = "map";
	wf->putDT(XMLRoot, PrologDTypeMap, PrologDTDMap, false);  
#endif

	wf->startBlock(HTMwr::XMLRoot);
	if (UseDITAMapID)
		wf->strAttr(IDattr, DITAMapID ? DITAMapID : DITAMapBase);
	wf->strAttr(HTMwr::XHLangAttr, HTMwr::XhtmlLang);
	wf->endElem(true);
	wf->putEnd();
	if (HTMwr::GeneratorTag == 'C') {
		wf->startComment();
		wf->putStr("generated by ");
		wf->putStr(HTMwr::FilterVer);
		wf->endComment();
	}
	wf->putEnd();

	if (DITAVer > 0) {
		if (DITAMapTitle
		 || (DITAMapTitleAlt
		  && UseAltMapTitle)) {
			wf->startSBlock("title");
			if (DITAMapTitleAlt
			 && UseAltMapTitle)
				wf->putStr(DITAMapTitleAlt);
			else
				wf->putStr(DITAMapTitle);
			wf->endBlock("title");
			wf->putEnd();
		}
	}
	DITAMapLevel = 0;
	DITAMapDiv = wf->NewDiv();
	if (DITAMapHead) {
		wf->startBlock("topichead");
		wf->strAttr("navtitle", DITAMapHead);
		wf->endElem(true);
		wf->putEnd();
	}
	FirstTopicRef = true;
	DITAMapVals.writeallval(wf, WriteDITATopicrefs);
	while (DITAMapLevel) {
		wf->endBlock(CurrMapTags[DITAMapLevel]);
		wf->putEnd();
		DITAMapLevel--;
	}
	if (DITAMapHead) {
		wf->endBlock("topichead");
		wf->putEnd();
	}
	wf->SelectDiv(DITAFullMapDiv);
	wf->WriteDiv(DITAMapDiv);
	wf->SelectDiv(DITAFullMapDiv);

	// write reltable here
	WriteDITARelTable(wf);
	wf->endBlock(HTMwr::XMLRoot);
	wf->putEnd();

	// write DCL file with info for book-level map
	WriteDITABookInfo(wf);
}

long HXMwr::DITAMapLevel = 0;
DCilist HXMwr::DITAMapLevels;
DCilist HXMwr::DITAOrigMapLevels;
long HXMwr::DITAMapSeq = 0;
DCilist HXMwr::DITAMapSeqs;
unc HXMwr::DITAMapUsage = 'T';
DCilist HXMwr::DITAMapUsages;
char *HXMwr::CurrMapTags[MapLevMax];
bool HXMwr::FirstTopicRef = false;
long HXMwr::MapLevelOffset = 0;

void HXMwr::WriteDITATopicrefs(DCfile *w, void *v, long i)
{
	if (i == 0)
		return;

	HTMwfile *wf = (HTMwfile *) w;
	dmapprop *tr = (dmapprop *) v;
	long lev = tr->level;

	if (FirstTopicRef) {
		MapLevelOffset = lev - 1; 
		FirstTopicRef = false;
	}
	else if (lev > 1)
		lev -= MapLevelOffset;

	while (lev <= DITAMapLevel) { // close levels
		wf->endBlock(CurrMapTags[DITAMapLevel]);
		wf->putEnd();
		DITAMapLevel--;
	}
	if (tr->anchor) {
		wf->startElem("anchor");
		wf->strAttr(IDattr, tr->tid);
		wf->endElem();
		wf->putEnd();
	}
	else if (tr->navref) {
		wf->startElem("navref");
		wf->strAttr("mapref", tr->tid);
		wf->endElem();
		wf->putEnd();
	}
	else {
		CurrMapTags[++DITAMapLevel] = tr->noref ? "topichead" : "topicref";
		wf->startBlock(CurrMapTags[DITAMapLevel]);
		if (!tr->noref) {
			if (tr->tid
			 && MapTopicID
			 && !strchr(tr->ref, '#')) {
				char *ref = NewName(tr->ref, strlen(tr->ref) + strlen(tr->tid) + 2);
				strcat(ref, "#");
				strcat(ref, tr->tid);
				tr->ref = ref;
			}
			wf->strAttr("href", tr->ref);
		}
		if (tr->mapref)
			wf->strAttr("format", "ditamap");
		else {
			wf->strAttr("type", tr->typ);
			wf->putEnd();
			if (tr->notoc)
				wf->strAttr("toc", "no");
			else
				wf->strAttr("navtitle", tr->ntitle);
			if (!DITAMapHeadAlt && tr->ntitle)
				DITAMapHeadAlt = tr->ntitle;
			if (tr->locktitle)
				wf->strAttr("locktitle", "yes");
		}
		if (tr->attrs) {
			while ((tr->attrs = tr->attrs->next) != NULL) {
				tr->attrnames = tr->attrnames->next;
				wf->strAttr((char *) tr->attrnames->name, (char *) tr->attrs->name);
			}
		}
		wf->endElem(true);
		wf->putEnd();
	}
	if (MapTopicmeta
	 && (tr->ltext
	  || tr->stitle
	  || tr->sdesc)) {
		wf->startBlock("topicmeta");
		// add attributes?
		wf->endElem(true);
		if (tr->ltext)
			wf->writeTextBlock("linktext", tr->ltext);
		if (tr->stitle)
			wf->writeTextBlock("searchtitle", tr->stitle);
		if (tr->sdesc)
			wf->writeTextBlock("shortdesc", tr->sdesc);
		wf->endBlock("topicmeta");
		wf->putEnd();
	}
}


long HXMwr::DITARelNameCount = 0;   // rows of reltable body
long HXMwr::DITARelNum = 0;
DCnlist HXMwr::DITARelNames;    // name indexed by RelNum, init'd for basic three
DCilist HXMwr::DITARelTopics;   // RelNum indexed by topicnum
long HXMwr::DITATypeNameCount = 0;  // cols of reltable
long HXMwr::DITATypeNum = 0;
DCnlist HXMwr::DITATopicTypes;  // root name indexed by TypeNum
DCilist HXMwr::DITATypeUsage;   // TypeNum indexed by topicnum
DCnlist HXMwr::DITALinkingAttr; // linking attr by topicnum
bool HXMwr::DITAUseRelNameCol = true;

void HXMwr::WriteDITARelTable(HTMwfile *wf)
{
	long i = 0;
	long celldiv = 0;

	if (!DITARelNameCount
	 || !DITATypeNameCount)
		return;

	if (DITAVer == 0)   // turn off unsupported feature
		DITAUseRelNameCol = false;

	wf->startSBlock("reltable");
	wf->putEnd();
	wf->startSBlock("relheader");
	wf->putEnd();
	// write colspecs for name and all types used
	bool sect = IniFile->Section("DITARelGroups");
	for (DITATypeNum = (DITAUseRelNameCol ? 0 : 1);
			 DITATypeNum <= DITATypeNameCount;
			 DITATypeNum++) {
		wf->startElem("relcolspec");
		wf->strAttr("type", (DITATypeNum == 0) ? "name" : DITATopicTypes.find(DITATypeNum));
		if (DITATypeNum
		 && sect
		 && IniFile->Find(DITATopicTypes.find(DITATypeNum)))
			wf->strAttr("collection-type", IniFile->StrRight());
		wf->endElem();
		wf->putEnd();
	}
	wf->endBlock("relheader");
	wf->putEnd();
	// write a row for each RelName
	for (DITARelNum = 1; DITARelNum <= DITARelNameCount; DITARelNum++) {
		wf->startSBlock("relrow");
		DITARelCellList = new DCilist;
		DITARelRowList.add(DITARelCellList, DITARelNum);
		wf->putEnd();
		for (DITATypeNum = (DITAUseRelNameCol ? 0 : 1);
				 DITATypeNum <= DITATypeNameCount;
				 DITATypeNum++) {
			wf->startSBlock("relcell");
			if (DITATypeNum == 0) {
				wf->startElem("data");
				wf->strAttr("type", "name");
				wf->strAttr("value", DITARelNames.find(DITARelNum));
				wf->endElem();
			}
			else if (DITATypeUsage(DITATypeNum)) {  // there are topics of that type
				celldiv = wf->NewDiv();
				DITARelTopics.writeall(wf, WriteRelTableRef);
				if (wf->LenDiv() == 0) {
					wf->SelectDiv(DITAFullMapDiv);
					wf->DeleteDiv(celldiv);
				}
				else {
					wf->putEnd();
					DITARelCellList->append(celldiv, DITATypeNum);
					wf->SelectDiv(DITAFullMapDiv);
					wf->WriteDiv(celldiv);
				}
				wf->SelectDiv(DITAFullMapDiv);
			}
			wf->endBlock("relcell");
			wf->putEnd();
		}
		wf->endBlock("relrow");
		wf->putEnd();
	}
	wf->endBlock("reltable");
	wf->putEnd();
}


void HXMwr::WriteRelTableRef(DCwfile *w, long v, long i)
{
	if (i == 0)
		return;

	HTMwfile *wf = (HTMwfile *) w;
	char *ln = NULL;
	dmapprop *tr = (dmapprop *) DITARelVals.find(i);

	if ((DITATypeUsage.find(i) == DITATypeNum)  // col is correct
	 && (DITARelNum == v)) {            // row is correct	
		wf->startElem("topicref");
		if (!tr->noref)
			wf->strAttr("href", tr->ref);
		wf->strAttr("type", tr->typ);
		wf->putEnd();
		wf->strAttr("navtitle", tr->ntitle);
		if ((ln = DITALinkingAttr.find(i)) != NULL)
			wf->strAttr("linking", ln);
		wf->endElem();
	}
}


// info for book map

long HXMwr::DITAMapDiv = 0;             // div for topicrefs before reltable
long HXMwr::DITAFullMapDiv = 0;         // div for map when writing only .dtf
DCvlist HXMwr::DITARelRowList;          // cell lists indexed by row for 1..n
DCilist *HXMwr::DITARelCellList = NULL; // cell divs indexed by col for 1..n

void HXMwr::WriteDITABookInfo(HTMwfile *wf)
{
	long row = 0;
	long col = 0;
	long div = 0;
	char *name = wf->getBaseName();
	char *fn = NewName(name, strlen(name) + 5);
	strcat(fn, ".dtf");
	DCLwfile *df = new DCLwfile(fn, fasc);
	DCctl *cp = new DCctl(ecode, 2, 10, 1, 0);

	if (MapBookTopics) {  // write full info to merge into book map
		// write DITAMapDiv in ecode ctl 2/10/1
		if (DITAMapDiv) {
			wf->SelectDiv(DITAMapDiv);
			name = wf->ReadDiv();
			wf->SelectDiv(0);
			cp->ex(name);
			df->putCtl(*cp);
		}

		// write col count ctl (ilong = DITATypeNameCount) 2/53/1
		cp->dt(ilong);
		cp->min(53);
		cp->siz(DITATypeNameCount);
		df->putCtl(*cp);

		// write header row ctl (ilong = 0) 2/54/2
		cp->min(54);
		cp->dat(2);
		cp->siz((long) 0);
		df->putCtl(*cp);

		// write col names in individual ctls 2/53/7
		cp->dt(etext);
		cp->min(53);
		cp->dat(7);
		for (col = 1; col <= DITATypeNameCount; col++) {
			cp->siz((long) 0);
			cp->ex(DITATopicTypes.find(col));
			df->putCtl(*cp);
		}

		for (row = 1; row <= DITARelNameCount; row++) {
			// write body row ctl with row name etext 2/54/1
			cp->dt(etext);
			cp->min(54);
			cp->dat(1);
			cp->siz((long) 0);
			cp->ex(DITARelNames.find(row));
			df->putCtl(*cp);

			// write cell ctls for body row cols 1..n ecode 2/56/1
			cp->dt(ecode);
			cp->min(56);
			cp->dat(1);
			DITARelCellList = (DCilist *) DITARelRowList.find(row);
			for (col = 1; col <= DITATypeNameCount; col++) {
				// make ctl for every col even if empty
				cp->siz((long) 0);
				if ((div = DITARelCellList->find(col)) != 0) {
					cp->dt(ecode);
					wf->SelectDiv(div);
					cp->ex(wf->ReadDiv());
				}
				else
					cp->dt(ilong);
				df->putCtl(*cp);
			}
		}
	}
	else {  // need only topicref for chapter map itself, format="ditamap"
		div = wf->NewDiv();
		// may be chapter or appendix, or even part
		//wf->startElem(UseChapterTopicref ? "topicref" : "chapter");
		wf->startElem("topicref");
		wf->strAttr("href", DITAMapFileName);
		wf->strAttr("format", "ditamap");
		wf->putEnd();
		wf->strAttr("navtitle", DITAMapHead ? DITAMapHead : DITAMapHeadAlt);
		if (UseDITAMapID)
			wf->strAttr(IDattr, DITAMapID ? DITAMapID : DITAMapBase);
		wf->endElem();
		wf->putEnd();
		wf->SelectDiv(div);
		cp->ex(wf->ReadDiv());
		wf->SelectDiv(0);
		df->putCtl(*cp);
	}

	df->CloseFile();
}

bool HXMwr::AllowPartAppendix = false;
char *HXMwr::DITABookMapName = NULL;
char *HXMwr::DITABookMapID = NULL;
char *HXMwr::DITABookMapTitle = NULL;
char *HXMwr::DITABookMapHead = NULL;

DCnlist HXMwr::FileExtTypes;
npair HXMwr::FileExtTypesSet[] = {
 { 1, "toc"},
 { 2, "frm"},
 { 3, "chp"},
 { 4, "idx"},
 { 5, "bkm"},
 { 6, "gen"},
 { 0, NULL }
 };

DCnlist HXMwr::SegmentTypes;
npair HXMwr::SegmentTypesSet[] = {
 { 1, "None"},
 { 2, "multiseg"},
 { 3, "startseg"},
 { 4, "continueseg"},
 { 5, "endseg"},
 { 0, NULL }
 };

DCnlist HXMwr::BookFileTypes;
npair HXMwr::BookFileTypesSet[] = {
 { 1, "Part"},     // basic
 { 2, "Chapter"},
 { 3, "Appendix"},
 { 4, "Front"},
 { 5, "Back"},
 { 10, "Lists"},   // front and back
 { 11, "Notice"},
 { 12, "Dedication"},
 { 13, "Colophon"},
 { 14, "Abstract"},
 { 15, "Draftintro"},
 { 16, "Preface"},
 { 17, "Amendment"},
 { 20, "TOC"},     // lists
 { 21, "LOF"},
 { 22, "LOT"},
 { 23, "Abbr"},
 { 24, "Trademark"},
 { 25, "Biblio"},
 { 26, "Glossary"},
 { 27, "IX"},
 { 28, "Booklist"},
 { 0, NULL }
 };


DCnlist HXMwr::PropertyTypes;
npair HXMwr::PropertyTypesSet[] = {
 { 1, "NoLink"},
 { 2, "ElementBefore"},
 { 3, "ElementAfter"},
 { 0, NULL }
 };


// [DITARelBookGroups] .ini section


void HXMwr::WriteDITABookMap(DCrfile *rf, char *destname, char *buf)
{
	// called with .lst file, merge chapter map info into book map
	// called from ProcListFile in dwhtmxf, IniFile set, DITAOptions read

	DCini::ProcIniSect("DITABookmapOptions");
	bool bookmap = false;
	if ((DITAVer > 0)
	 && (DITABookmapType == 'B'))
		bookmap = true;

	if (DITABookMapName)
		destname = DITABookMapName;
	char *dest = HTMwr::ReplaceExt(destname, bookmap ? ".bookmap" : ".ditamap");
	HTMwfile *wf = new HTMwfile(dest);
	if (wf->FErr() != fok)
		return;
	wf->SetXml(true);

	// write header and startSBlock for map's topichead
	wf->putXML(HTMwr::XMLEncoding, HTMwr::XMLVer);

	long tnum = DTopicTypes->getitem(bookmap ? "bookmap" : "map");

	tagset *ttags = (tagset *) DTagSets->find(tnum);
	if (!ttags)
		ttags = DMapTags;

	char *troot = ttags->names->find(1);
	if (!troot)
		troot = "map";

	HTMwr::XMLRoot = troot;
	wf->putDT(troot, ttags->dtype, ttags->dtd, false);  

#if 0
	HTMwr::XMLRoot = bookmap ? "bookmap" : "map";
	if (bookmap)
		wf->putDT(HTMwr::XMLRoot, HTMwr::PrologDTypeBookmap, HTMwr::PrologDTDBookmap, false);  
	else
		wf->putDT(HTMwr::XMLRoot, HTMwr::PrologDTypeMap, HTMwr::PrologDTDMap, false);
#endif
  
	wf->startBlock(HTMwr::XMLRoot);
	wf->strAttr(IDattr, DITABookMapID ? DITABookMapID : destname);
	wf->strAttr(HTMwr::XHLangAttr, HTMwr::XhtmlLang);
	wf->endElem(true);
	wf->putEnd();
	if (HTMwr::GeneratorTag == 'C') {
		wf->startComment();
		wf->putStr("generated by ");
		wf->putStr(HTMwr::FilterVer);
		wf->endComment();
	}
	wf->putEnd();

	if (bookmap && DITABookTitle) {
		wf->startSBlock("booktitle");
		if (DITABookLibrary) {
			wf->startSBlock("booklibrary");
			DCmacr::WriteMacro(wf, DITABookLibrary);
			wf->endBlock("booklibrary");
			wf->putEnd();
		}
		wf->startSBlock("mainbooktitle");
		wf->putStr(DITABookTitle);
		wf->endBlock("mainbooktitle");
		wf->putEnd();
		if (DITABookSubtitle) {
			wf->startSBlock("booktitlealt");
			wf->putStr(DITABookSubtitle);
			wf->endBlock("booktitlealt");
		}
		wf->endBlock("booktitle");
		wf->putEnd();
	}
	else if (DITABookMapTitle
	 && (DITAVer > 0)) {
		wf->startSBlock("title");
		wf->putStr(DITABookMapTitle);
		wf->endBlock("title");
		wf->putEnd();
	}
	DITAMapLevel = 0;

	if (bookmap) {
		if (DITABookMeta) {
			wf->startSBlock("bookmeta");
			DCmacr::WriteMacro(wf, DITABookMeta);
			wf->endBlock("bookmeta");
			wf->putEnd();
		}
		FileExtTypes.init(FileExtTypesSet);
		SegmentTypes.init(SegmentTypesSet);
		BookFileTypes.init(BookFileTypesSet);
		PropertyTypes.init(PropertyTypesSet);
	}
	else if (DITABookMapHead) {
		wf->startBlock("topichead");
		wf->strAttr("navtitle", DITABookMapHead);
		wf->endElem(true);
		wf->putEnd();
	}

	// process each line in list
	long pnum = 0;
	long pcount = 0;
	long col = 0;
	long row = 0;
	char *part = NULL;
	DCLrfile *rpf = NULL;
	DCctl *cp = NULL;

	DCilist filelist;     // lists fnum by pnum (first fnum for StartSeg pnum)
	DCilist partlist;     // lists pnum by fnum {first pnum for MultiSeg fnum)
	DClist segmented;     // lists pnums with multiple fnums (StartSeg/EndSeg)
	DClist multiseg;      // lists fnums with multiple pnums (MultiSeg)
	DCnlist topicrefs;    // lists topicref blocks by fnum
	DCilist cols;         // lists all file col counts by fnum
	DCnlist comtypes;     // lists all col types used in any file by output col
	long ctcount = 0;
	DCnlist comnames;     // lists all row names used in any file by output row
	long cncount = 0;
	DCvlist relrows;      // lists all file rows lists by fnum
	DCvlist *rows = NULL;   // make for each file, points to cells list
	DCnlist *cells = NULL;  // make for each row, contains cell text
	DCvlist reltypes;      // lists all file coltypes by fnum
	DCnlist *coltypes = NULL; // for each file, col types 1..n
	DCvlist relnames;      // lists all file rownames by fnum
	DCnlist *rownames = NULL; // for each file, row names 1..n

	long fnum = 0;
	long fcount = 0;
	char *fmname = NULL;
	char *fmbase = NULL;
	char *fmext = NULL;
	DCnlist fmlist;
	DCilist fmtypes;
	long fmgroup = 0;
	DCilist fmgroups;

	long ftyp = 0;
	char *fprop = NULL;
	long fpval = 0;

	DClist skipfile;
	DClist partstart;
	long frontstart = 0;
	long backstart = 0;

	long fpbase = 0;
	long fpfb = 0;
	long fpltyp = 0;
	DCilist fpbases;
	DCilist fpfbs;
	DCilist fpltyps;
	bool notoc = true;
	char *crpos = NULL;

	while (rf->getLine(buf, TextBufMax)) {  // collect file info
		fnum++;
		fcount++;
		crpos = strchr(buf, '\r');
		fmbase = fmname = NewName(buf, crpos ? crpos - buf : 0);
		fmext = strrchr(fmname, '.');
		if (fmext) {
			fmbase = NewName(fmname, fmext - fmname);
			if (bookmap) {
				ftyp = FileExtTypes(++fmext);  // identify type by ext
				if (ftyp)
					fmtypes.append(ftyp, fnum);
			}
		}
		fmlist.add(fmbase, fnum);
	}

	bool segonly = false;
	bool inmultilist = false;
	bool startmultiseg = false;
	bool inmultiseg = false;
	bool endingseg = false;
	bool inseg = false;
	bool startfile = false;

	long propval = 0;
	DClist nolink;
	DClist elembefore;
	DClist elemafter;
	long segval = 0;
	DCnlist multisegnames;
	long nextseg = 0;
	DCnlist partsegnames;
	long startseg = 0;
	long endseg = 0;
	DCilist segspan;


	if (bookmap) {
		for (fnum = 1; fnum <= fcount; fnum++) {  // collect part info
			fmbase = fmlist.find(fnum);
			segonly = false;
			inmultilist = inmultiseg = false;
			if (endingseg) // previous file ended seg
				inseg = false;
			startfile = true;

			if (IniFile  // locate matching DITABookmapFiles entry
			 && IniFile->Section("DITABookmapFiles")
			 && IniFile->Find(fmbase)
			 && IniFile->ListRight()) {
				while (startfile || inmultiseg) {  // loop to process multiple pnums
					while ((fprop = IniFile->ListItem()) != NULL) {
						if ((segval = SegmentTypes(fprop)) != 0) {
							switch (segval) {
								case 1:  // None
									skipfile.add(fnum);
									segonly = true;
									break;
								case 2:  // MultiSeg
									inmultilist = true;
									nextseg = 0;
									multiseg.add(fnum);
									multisegnames.empty();
									continue;
								case 3:  // StartSeg
									inseg = true;
									startseg = fnum;
									break;
								case 4:  // ContinueSeg
									segonly = true;
									break;
								case 5:  // EndSeg
									if (inseg)
										endingseg = true;
									segspan.append(fnum, startseg);
									startseg = 0;
									segonly = true;
									break;
								default:
									break;
							}
							if (segonly) { // no new pnum here
								startfile = false;
								break;
							}
						}

						if (inmultilist) { // store IDs for each item
							if (*fprop != '#')
								break;
							multisegnames.add(fprop, ++nextseg);
							continue;
						}

						if (startmultiseg) { // increment pnum for each item
							partsegnames.add(fmbase, ++pnum);
							filelist.append(fnum, pnum);
							partlist.append(pnum, fnum);
							startmultiseg = false;
							startfile = false;
						}
						else if (startfile) {
							pnum++;
							filelist.append(fnum, pnum);
							partlist.append(pnum, fnum);
							if (inseg)  // starting this pnum
								segmented.add(pnum);
							startfile = false;
						}

						if ((propval = PropertyTypes(fprop)) != 0) {
							switch (propval) {
								case 1:  // NoLink
									nolink.add(pnum);
									break;
								case 2:  // ElementBefore
									elembefore.add(pnum);
									break;
								case 3:  // ElementAfter
									elemafter.add(pnum);
									break;
								default:
									break;
							}
							continue;
						}

						if ((fpval = BookFileTypes(fprop)) == 0)
							continue;

						if (fpval == 1)
							partstart.add(pnum);
						else if (fpval == 4)
							frontstart = 1;
						else if (fpval == 5)
							backstart = pnum;
						else if (fpval == 20)
							notoc = false;

						if (fpval < 10)
							fpbase = fpval;
						else if (fpval < 20)
							fpfb = fpval;
						else
							fpltyp = fpval;
					}

					// after last list item (or segonly)
					if (inmultilist) {
						inmultilist = false;
						inmultiseg = true;
						nextseg = 0;
					}
					if (inmultiseg) {
						if (((fmbase = multisegnames.find(++nextseg)) != NULL)
						 && IniFile->Find(fmbase)
						 && IniFile->ListRight()) {
							if (nextseg > 1) {   // store values
								fpbases.append(fpbase, pnum);
								fpfbs.append(fpfb, pnum);
								fpltyps.append(fpltyp, pnum);
							}
							startmultiseg = true;
						}
						else
							inmultiseg = false;
					}
				}
			}
			else {  // progress through Front, Chapter, Back by ftyp
				if (!inseg)
					pnum++;
				filelist.append(fnum, pnum);
				partlist.append(pnum, fnum);
				ftyp = fmtypes.find(fnum);
				switch (ftyp) {
					case 1:  // toc
						frontstart = 1;
						fpbase = 4;
						fpfb = 10;
						fpltyp = 20;
						notoc = false;
						break;

					case 2:  // frm
						frontstart = 1;
						fpbase = 4;
						fpfb = 10;
						fpltyp = 28;
						break;

					case 3:  // chp
					default:
						fpbase = 2;
						break;

					case 4:  // idx
						if (!backstart)
							backstart = pnum;
						fpbase = 5;
						fpfb = 10;
						fpltyp = 27;
						break;

					case 5:  // bkm
						if (!backstart)
							backstart = pnum;
						fpbase = 5;
						fpfb = 10;
						fpltyp = 28;
						break;

					case 6:  // gen
						fpfb = 10;
						fpltyp = 28;
						break;
				}
			}
			fpbases.append(fpbase, pnum);
			fpfbs.append(fpfb, pnum);
			fpltyps.append(fpltyp, pnum);
		}
	}
	pcount = pnum;

	// read all partfiles that are used into lists
	for (fnum = 1; fnum <= fcount; fnum++) {
		fmbase = fmlist.find(fnum);
		part = HTMwr::ReplaceExt(fmbase, ".dtf");  // topic ref file
		rpf = new DCLrfile(part);
		if (!rpf
		 || (rpf->FErr() != fok)) {
			HTMwr::LogEvent(logwarn, 1, "Missing .dtf for ", fmbase, ", map incomplete");
			continue;
		}
		if (bookmap
		  && skipfile.find(fnum))
			continue;

		if (MapBookTopics) {
			rows = new DCvlist;
			relrows.add(rows, fnum);
			coltypes = new DCnlist;
			reltypes.add(coltypes, fnum);
			rownames = new DCnlist;
			relnames.add(rownames, fnum);
		}

		// read all DCL ctrls
		while (!rpf->eof()) {
			cp = new DCctl;
			*cp = *rpf;

			// text block containing topicrefs, write directly
			if ((cp->maj() == 2)
			 && (cp->min() == 10)
			 && (cp->dat() == 1)
			 && (cp->dt() == ecode)) {
				if (bookmap)
					topicrefs.add((char *) cp->ex(), fnum);
				else
					wf->putStr((char *) cp->ex(), cp->siz());
				if (!MapBookTopics)
					break;  // just one chunk
			}

			// column count
			else if ((cp->maj() == 2)
			 && (cp->min() == 53)
			 && (cp->dat() == 1)
			 && (cp->dt() == ilong)) {
				col = cp->siz();
				cols.append(col, fnum);
			} 

			// table head row, get types next
			else if ((cp->maj() == 2)
			 && (cp->min() == 54)
			 && (cp->dat() == 2)
			 && (cp->dt() == ilong))
				col = row = 0;

			// column type name
			else if ((cp->maj() == 2)
			 && (cp->min() == 53)
			 && (cp->dat() == 7)
			 && (cp->dt() == etext)) {
				coltypes->add((char *) cp->ex(), ++col);
				if (!comtypes((char *) cp->ex()))
					comtypes.add((char *) cp->ex(), ++ctcount);
			} 

			// table body row, get name
			else if ((cp->maj() == 2)
			 && (cp->min() == 54)
			 && (cp->dat() == 1)
			 && (cp->dt() == etext)) {
				col = 0;
				cells = new DCnlist;
				rows->add(cells, ++row);
				rownames->add((char *) cp->ex(), row);
				if (!comnames((char *) cp->ex()))
					comnames.add((char *) cp->ex(), ++cncount);
			}

			// table cell with data
			else if ((cp->maj() == 2)
			 && (cp->min() == 56)
			 && (cp->dat() == 1)
			 && (cp->dt() == ecode))
				cells->add(NewName((char *) cp->ex(), cp->siz()), ++col);

			// table cell, empty
			else if ((cp->maj() == 2)
			 && (cp->min() == 56)
			 && (cp->dat() == 1)
			 && (cp->dt() == ilong))
				cells->add(NULL, ++col);

		}  // end of part file
		rpf->CloseFile();

	}  // end of all partfiles


	bool infront = false;
	bool inback = false;
	bool inlist = false;
	bool inpart = false;
	bool tocdone = false;
	bool parttag = false;
	bool chapstarted = false;
	char *ptag = NULL;
	char *pstr = NULL;
	char *nstr = NULL;
	bool blmac = false;
	char *BookListMacro = NULL;
	long sval = 0;
	char *selem = NULL;


	if (bookmap) {
		if (IniFile
		 && IniFile->Section("BooklistStart"))
			BookListMacro = IniFile->SecCont(true);
		else if (DCmacr::MacroIniFile
		 && DCmacr::MacroIniFile->Section("BooklistStart"))
			BookListMacro = DCmacr::MacroIniFile->SecCont(true);

		for (pnum = 1; pnum <= pcount; pnum++) {
			fpbase = fpbases.find(pnum);
			fpfb = fpfbs.find(pnum);
			fpltyp = fpltyps.find(pnum);

			fnum = filelist.find(pnum);
			fmbase = multiseg.find(fnum) ? partsegnames.find(pnum) : fmlist.find(fnum);


			// see if something precedes this item ****
			if (elembefore.find(pnum)) {
				// get list of items to put before
				if (IniFile->Section("BookmapElementBefore")
				 && IniFile->Find(fmbase)
				 && IniFile->ListRight()) {
					bool setfront = false;
					bool setback = false;
					bool setlist = false;
					while ((selem = IniFile->ListItem()) != NULL) {
						// if selem has a numeric suffix, look up with the
						// previous part
						long slen = strlen(selem) - 1;
						while (slen > 0) {
							if (isdigit(selem[slen]))
								slen--;
							else
								break;
						}
						char *key = NewName(selem, slen + 1);
						sval = BookFileTypes(key);
						DeleteName(key);

						if (sval < 4)  // Part, Chapter, Appendix not allowed
							continue;
						else if (sval == 4) {  // front
							setfront = true;
							setback = false;
							continue;
						}
						else if (sval == 5) {  // back
							setfront = false;
							setback = true;
							continue;
						}
						else if (sval == 10) {  // lists
							setlist = true;
							continue;
						}
						else if (sval >= 20) {
							// if booklist item, make sure booklists open
							setlist = true;

						}
						else {
							// if front or back item, make sure front or back is open
							// 14, 15, 16 = front, 17 = back, 11, 12, 13 = either
							setlist = false;
							switch (sval) {
								case 14:
								case 15:
								case 16:
									setfront = true;
									setback = false;
									break;

								case 17:
									setfront = false;
									setback = true;
									break;

								default:
									break;
							}
						}
						if (setfront) {
							if (inback || inpart) {  // oops  ****
							}
							if (!infront) {
								wf->putStr("<frontmatter>\n");
								infront = true;
							}
						}
						else if (setback) {
							if (!inback) {
								if (infront) {
									if (inlist) {
										wf->putStr("</booklists>\n");
										inlist = false;
									}
									wf->putStr("</frontmatter>\n");
									infront = false;
								}
								if (inpart) {
									wf->putStr("</part>\n");
									inpart = false;
								}
								wf->putStr("<backmatter>\n");
								inback = true;
							}
						}
						else if (!infront && !inback) {  // pick one
							if (!chapstarted) {
								wf->putStr("<frontmatter>\n");
								infront = true;
							}
							else {
								if (inpart) {
									wf->putStr("</part>\n");
									inpart = false;
								}
								wf->putStr("<backmatter>\n");
								inback = true;
							}
						}
						if (setlist) {
							if (!inlist) {
								wf->putStr("<booklists>\n");
								inlist = true;
							}
						}
						else if (inlist) {
							wf->putStr("</booklists>\n");
							inlist = false;
						}
						PutBookmapAddedElement(wf, sval, selem);
					}
				}
			}

			// determine type of element for this part

			// if Front, start frontmatter
			if (frontstart == pnum) {
				if (!infront) {
					wf->putStr("<frontmatter>\n");
					infront = true;
					tocdone = false;
				}
			}

			// if Back, start backmatter; ends at reltable
			if (backstart == pnum) {
				if (inpart) {
					wf->putStr("</part>\n");
					inpart = false;
				}
				if (!inback) {
					wf->putStr("<backmatter>\n");
					inback = true;
				}
			}

			if (infront || inback) {
				if (fpfb == 10) {
					if (!inlist) {
						wf->putStr("<booklists>\n");
						inlist = true;
						if (BookListMacro)
							DCmacr::WriteMacro(wf, BookListMacro);
						blmac = true;
					}
					if (fpltyp == 20)
						tocdone = true;
				}
				else if (inlist) {
					wf->putStr("</booklists>\n");
					inlist = false;
				}
				else if (BookListMacro
				 && !blmac) {
					wf->putStr("<booklists>\n");
					if (BookListMacro)
						DCmacr::WriteMacro(wf, BookListMacro);
					wf->putStr("</booklists>\n");
					blmac = true;
				}
			}

			// Front ends at chapter or appendix after TOC if any
			if (infront
			 && (pnum > frontstart)
			 && (tocdone || notoc)
			 && ((fpbase == 2) || (fpbase == 3))) {
				if (inlist) {
					wf->putStr("</booklists>\n");
					inlist = false;
				}
				else if (BookListMacro
				 && !blmac) {
					wf->putStr("<booklists>\n");
					if (BookListMacro)
						DCmacr::WriteMacro(wf, BookListMacro);
					wf->putStr("</booklists>\n");
					blmac = true;
				}
				wf->putStr("</frontmatter>\n");
				infront = false;
				chapstarted = true;
			}

			// if Part, set part
			if (partstart.find(pnum)) {
				if (inpart && parttag)
					wf->putStr("</part>\n");
				if ((fpbase == 2)  // part contains chapter
				 || ((fpbase == 3)
				  && AllowPartAppendix)) {
					wf->putStr("<part");
					PutBookmapTopicrefAttrs(wf, fmbase);
					wf->putStr(">\n");
					parttag = true;
				}
				inpart = true;
				chapstarted = true;
			}

			if (fpbase == 3) {  // appendix
				if (inpart
				 && !AllowPartAppendix) {
					wf->putStr("</part>\n");
					inpart = false;
				}
				chapstarted = true;
			}

			// Chapter or Appendix just need their own tags
			switch (fpbase) {
				case 1:
					ptag = "part";
					break;
				case 2:  // chapter before TOC remains topicref
					ptag = infront ? "topicref" : "chapter";
					if (!infront)
						chapstarted = true;
					break;
				case 3:
					ptag = "appendix";
					break;
				case 4:  // front
					switch (fpfb) {
						case 10:  // list
							ptag = SetBookMapListTag(fpltyp);
							break;
						case 11:  // Notice
							ptag = "notice";
							break;
						case 12:  // Dedication
							ptag = "dedication";
							break;
						case 13:  // Colophon
							ptag = "colophon";
							break;
						case 14:  // Abstract
							ptag = "bookabstract";
							break;
						case 15:  // Draftintro
							ptag = "draftintro";
							break;
						case 16:  // Preface
							ptag = "preface";
							break;
						default:
							ptag = "topicref";
							break;
					}
					break;

				case 5:  // back
					switch (fpfb) {
						case 10:  // list
							ptag = SetBookMapListTag(fpltyp);
							break;
						case 11:  // Notice
							ptag = "notice";
							break;
						case 12:  // Dedication
							ptag = "dedication";
							break;
						case 13:  // Colophon
							ptag = "colophon";
							break;
						case 17:  // Amendment
							ptag = "amendment";
							break;
						default:
							ptag = "topicref";
							break;
					}
					break;

				default:
					ptag = "topicref";
					break;
			}

			if (segmented.find(pnum)) {  // wrap all seg topicrefs
				nstr = NULL;
				if ((endseg = segspan.find(fnum)) == fnum) {  // just one
					pstr = topicrefs.find(fnum);
					nstr = ChangeTags(pstr, "topicref", ptag);
				}
				if (!nstr) {  // must wrap
					wf->putChar('<');
					wf->putStr(ptag);
					PutBookmapTopicrefAttrs(wf, fmbase);
					wf->putStr(">\n");
					endseg = segspan.find(fnum);
					for ( ; fnum <= endseg; fnum++)
						wf->putStr(topicrefs.find(fnum));
					wf->putStr("</");
					wf->putStr(ptag);
					wf->putStr(">\n");
				}
				else 
					wf->putStr(nstr);
			}
			else {
				pstr = topicrefs.find(fnum);
				if (multiseg.find(fnum))
					pstr = ExtractTopicref(pstr, fmbase);
				// try to replace first and last topicref with ptag
				nstr = ChangeTags(pstr, "topicref", ptag);
				if (!nstr) {  // must wrap
					wf->putChar('<');
					wf->putStr(ptag);
					PutBookmapTopicrefAttrs(wf, fmbase);
					wf->putStr(">\n");
					wf->putStr(pstr);
					wf->putStr("</");
					wf->putStr(ptag);
					wf->putStr(">\n");
				}
				else 
					wf->putStr(nstr);
			}

			// see if something follows this item ****
			if (elemafter.find(pnum)) {
				if (IniFile->Section("BookmapElementAfter")
				 && IniFile->Find(fmbase)
				 && IniFile->ListRight()) {
					bool setfront = false;
					bool setback = false;
					bool setlist = false;
					while ((selem = IniFile->ListItem()) != NULL) {
						// if selem has a numeric suffix, look up with the
						// previous part
						long slen = strlen(selem) - 1;
						while (slen > 0) {
							if (isdigit(selem[slen]))
								slen--;
							else
								break;
						}
						char *key = NewName(selem, slen + 1);
						sval = BookFileTypes(key);
						DeleteName(key);

						if (sval < 4)  // Part, Chapter, Appendix not allowed
							continue;
						else if (sval == 4) {  // front
							setfront = true;
							setback = false;
							continue;
						}
						else if (sval == 5) {  // back
							setfront = false;
							setback = true;
							continue;
						}
						else if (sval == 10) {  // lists
							setlist = true;
							continue;
						}
						else if (sval >= 20) {
							// if booklist item, make sure booklists open
							setlist = true;
						}
						else {
							// if front or back item, make sure front or back is open
							// 14, 15, 16 = front, 17 = back, 11, 12, 13 = either
							setlist = false;
							switch (sval) {
								case 14:
								case 15:
								case 16:
									setfront = true;
									setback = false;
									break;

								case 17:
									setfront = false;
									setback = true;
									break;

								default:
									break;
							}
						}
						if (setfront) {
							if (inback || inpart) {  // oops  ****
							}
							if (!infront) {
								wf->putStr("<frontmatter>\n");
								infront = true;
							}
						}
						else if (setback) {
							if (!inback) {
								if (infront) {
									if (inlist) {
										wf->putStr("</booklists>\n");
										inlist = false;
									}
									wf->putStr("</frontmatter>\n");
									infront = false;
								}
								if (inpart) {
									wf->putStr("</part>\n");
									inpart = false;
								}
								wf->putStr("<backmatter>\n");
								inback = true;
							}
						}
						else if (!infront && !inback) {  // pick one
							if (!chapstarted) {
								wf->putStr("<frontmatter>\n");
								infront = true;
							}
							else {
								if (inpart) {
									wf->putStr("</part>\n");
									inpart = false;
								}
								wf->putStr("<backmatter>\n");
								inback = true;
							}
						}
						if (setlist) {
							if (!inlist) {
								wf->putStr("<booklists>\n");
								inlist = true;
							}
						}
						else if (inlist) {
							wf->putStr("</booklists>\n");
							inlist = false;
						}
						PutBookmapAddedElement(wf, sval, selem);
					}
				}

			}
		}

		// at end of last part
		if (inback) {
			if (inlist) {
				wf->putStr("</booklists>\n");
				inlist = false;
			}
			wf->putStr("</backmatter>\n");
			inback = false;
		}
		else if (inpart) {
			wf->putStr("</part>\n");
			inpart = false;
		}

	}
	else if (DITABookMapHead) {	// write closing topichead
		wf->endBlock("topichead");
		wf->putEnd();
	}

	if (MapBookTopics
	 && MapBookRelTable
	 && ctcount
	 && cncount) {
		// write opening of reltable
		if (DITAVer == 0)   // turn off unsupported feature
			DITAUseRelNameCol = false;

		wf->startSBlock("reltable");
		wf->putEnd();
		wf->startSBlock("relheader");
		wf->putEnd();
		// write colspecs for name and all types used
		bool sect = IniFile->Section("DITARelBookGroups");
		if (!sect)
			sect = IniFile->Section("DITARelGroups");
		for (col = (DITAUseRelNameCol ? 0 : 1); col <= ctcount; col++) {
			wf->startElem("relcolspec");
			wf->strAttr("type", (col == 0) ? "name" : comtypes.find(col));
			if (col
			 && sect
			 && IniFile->Find(comtypes.find(col)))
				wf->strAttr("collection-type", IniFile->StrRight());
			wf->endElem();
			wf->putEnd();
		}
		wf->endBlock("relheader");
		wf->putEnd();

		long pcol = 0;
		long prow = 0;
		char *rowname = NULL;
		char *text = NULL;

		// write cells from each file merged by type and name
		for (row = 1; row <= cncount; row++) {
			wf->startSBlock("relrow");
			wf->putEnd();
			for (col = (DITAUseRelNameCol ? 0 : 1); col <= ctcount; col++) {
				wf->startSBlock("relcell");
				rowname = comnames.find(row);
				if (col == 0) {
					wf->startElem("data");
					wf->strAttr("type", "name");
					wf->strAttr("value", rowname);
					wf->endElem();
				}
				else {  // get topic of this type and name from all files
					for (fnum = 1; fnum <= fcount; fnum++) {
						if (skipfile.find(fnum))
							continue;
						// find pcol = col number of this coltype in part file
						if (((coltypes = (DCnlist *) reltypes.find(fnum)) == NULL)
						 || ((pcol = coltypes->operator()(comtypes.find(col))) == 0))
							continue;  // file doesn't have this col type
						// find prow = row number of this name in part file
						if (((rownames = (DCnlist *) relnames.find(fnum)) == NULL)
						 || ((prow = rownames->operator()(rowname)) == 0))
							continue;  // file doesn't have this row type
						// find prow DCnlist and look up pcol; add text if found
						if (((rows = (DCvlist *) relrows.find(fnum)) == NULL)
						 || ((cells = (DCnlist *) rows->find(prow)) == NULL)
						 || ((text = cells->find(pcol)) == NULL))
							continue;  // file doesn't have this combination
						wf->putStr(text);  // found, write it
					}
				}
				wf->endBlock("relcell");
				wf->putEnd();
			}
			wf->endBlock("relrow");
			wf->putEnd();
		}
		// write ending of reltable
		wf->endBlock("reltable");
		wf->putEnd();
	}
	// write ending of map
	wf->endBlock(HTMwr::XMLRoot);
	wf->putEnd();
	wf->CloseFile();
}


char *HXMwr::SetBookMapListTag(long fpltyp)
{
	char *ptag = NULL;

	switch (fpltyp) {
		case 20: // TOC
			ptag = "toc";
			break;
		case 21:  // LOF
			ptag = "figurelist";
			break;
		case 22:  // LOT
			ptag = "tablelist";
			break;
		case 23:  // Abbr
			ptag = "abbrevlist";
			break;
		case 24:  // Trademark
			ptag = "trademarklist";
			break;
		case 25:  // Biblio
			ptag = "bibliolist";
			break;
		case 26:  // Glossary
			ptag = "glossarylist";
			break;
		case 27:  // IX
			ptag = "indexlist";
			break;
		case 28:  // Booklist
			ptag = "booklist";
			break;
	}
	return ptag;
}

char *HXMwr::ExtractTopicref(char *pstr, char *tid)
{
	if (!pstr || !tid)
		return pstr;

	// return topicref with specified topicid with any nested topicrefs
	long plen = strlen(pstr);
	char *otag = "topicref";
	long olen = strlen(otag);
	long tlen = strlen(tid);
	char *etag = NULL;
	char *idtag = NULL;
	long fpos = 1;
	long spos = 0;
	long epos = 0;
	bool scanning = true;
	bool matched = false;
	long nest = 0;
	long snest = 0;

	// identify topicref start
	while (scanning) {
		for (; fpos < plen; fpos++) {
			if (!strncmp(&pstr[fpos], otag, olen))
				break;
		}
		if (fpos == plen)  // not found at all
			return pstr;
		if (pstr[fpos - 1] == '<') { // start tag
			nest++;
			if (!matched) {   // find href within it
				if ((etag = strchr(pstr + fpos, '>')) == NULL)
					return pstr;  // not well formed, give up
				if (((idtag = strchr(pstr + fpos, '#')) != NULL) // has an id
				 && (idtag < etag)                 // in this topicref
				 && !strnicmp(tid, idtag, tlen)) { // found start
					matched = true;
					spos = fpos - 1;  // may be 0 if at start of pstr
					snest = nest - 1;
				}
				fpos = etag - pstr;
			}
			else  // already matched, is nested topicref
				fpos += olen;
		}
		else if (pstr[fpos - 1] == '/') {  // end tag
			nest--;
			// if matched, find closing tag for this topicref
			if (matched
			 && (nest == snest)) {
				if ((etag = strchr(pstr + fpos, '>')) == NULL)
					return pstr;  // not well formed, give up
				epos = etag - pstr;
				break;
			}
			else
				fpos += olen;
		}
	}
	// return new string with content
	if (epos) {
		char *nstr = NewName((epos - spos) + 3);
		strncpy(nstr, pstr + spos, (epos - spos) + 1);
		strcat(nstr, "\n");
		return nstr;
	}
	return pstr;
}


char *HXMwr::ChangeTags(char *pstr, char *otag, char *ntag)
{
	// replace first and last occurences of otag in pstr with ntag
	// if not possible, return NULL to indicate wrap is needed
	long plen = strlen(pstr);
	long olen = strlen(otag);
	long nlen = strlen(ntag);
	long fpos, epos;

	for (fpos = 1; fpos < plen; fpos++)
		if (!strncmp(&pstr[fpos], otag, olen))
			break;
	if (fpos == plen)  // not found at all
		return NULL;

	char *eptr = pstr + plen - 1;
	while ((eptr > pstr)
	 && isspace(*eptr))
		eptr--;

	if ((*eptr == '>')  // see if simple single element
	 && (*(eptr - 1) == '/')
	 && (strchr(pstr, '>') == eptr)) {
		eptr = NewName((short) (plen + nlen - olen));
		memcpy(eptr, pstr, fpos);
		memcpy(eptr + fpos, ntag, nlen);
		memcpy(eptr + fpos + nlen, pstr + fpos + olen, plen - (fpos + olen));
		return eptr;
	}

	for (epos = plen - (olen + 1); epos > fpos; epos--) {
		if (!strncmp(&pstr[epos], otag, olen))
			break;
	}

	if ((epos == fpos)  // only one tag
	 || (pstr[epos - 1] != '/')) // or last not an end tag
		return NULL;

	// see if fully nested; if not, must wrap
	char *nptr = pstr + fpos + olen;
	long nest = 1;

	while ((nptr = strstr(nptr, otag)) != NULL) {
		if (nptr == pstr + epos)  // at last end tag
			break;
		if (*(nptr - 1) == '/') { // earlier end tag
			if (--nest == 0)        // closes initial start tag
				return NULL;
		}
		if (*(nptr - 1) == '<')  // start tag
			nest++;
	}

	long xlen = plen + ((nlen - olen) * 2);
	char *nstr = NewName(xlen + 1);

	strncpy(nstr, pstr, fpos);
	strcat(nstr, ntag);
	strncat(nstr, pstr + fpos + olen, epos - (fpos + olen));
	strcat(nstr, ntag);
	strcat(nstr, pstr + epos + olen);
	return nstr;
}


void HXMwr::PutBookmapAddedElement(HTMwfile *wf, long etype, char *key)
{
	// write tag for front or backmatter item
	char *ptag = "topicref";

	if (etype >= 20) {
		ptag = SetBookMapListTag(etype);
	}
	else {
		switch (etype) {
			case 11:  // Notice
				ptag = "notice";
				break;
			case 12:  // Dedication
				ptag = "dedication";
				break;
			case 13:  // Colophon
				ptag = "colophon";
				break;
			case 14:  // Abstract
				ptag = "bookabstract";
				break;
			case 15:  // Draftintro
				ptag = "draftintro";
				break;
			case 16:  // Preface
				ptag = "preface";
				break;
			case 17:  // Amendment
				ptag = "amendment";
				break;
			default:
				break;
		}
	}

	wf->putChar('<');
	wf->putStr(ptag);
	PutBookmapTopicrefAttrs(wf, key);
	wf->putStr("/>\n");
}


void HXMwr::PutBookmapTopicrefAttrs(HTMwfile *wf, char *key)
{
	bool href = false;

	if (IniFile) {
		if (IniFile->Section("DITABookmapHrefs")
		 && IniFile->Find(key)) {
			href = true;
			wf->putStr("\n href=\"");
			wf->putStr(IniFile->StrRight());
			wf->putChar('"');
		}
		if (href) {
			if (IniFile->Section("DITABookmapHrefTypes")
			 && IniFile->Find(key)) {
				wf->putStr(" type=\"");
				wf->putStr(IniFile->StrRight());
				wf->putChar('"');
			}
			if (IniFile->Section("DITABookmapHrefFormats")
			 && IniFile->Find(key)) {
				wf->putStr(" format=\"");
				wf->putStr(IniFile->StrRight());
				wf->putChar('"');
			}
			if (IniFile->Section("DITABookmapHrefScopes")
			 && IniFile->Find(key)) {
				wf->putStr(" scope=\"");
				wf->putStr(IniFile->StrRight());
				wf->putChar('"');
			}
		}
		if (IniFile->Section("DITABookmapTitles")
		 && IniFile->Find(key)) {
			if (href)
				wf->putEnd();
			else
				wf->putChar(' ');
			wf->putStr("navtitle=\"");
			wf->putStr(IniFile->StrRight());
			wf->putChar('"');
		}
		if (IniFile->Section("DITABookmapOutputclasses")
		 && IniFile->Find(key)) {
			if (href)
				wf->putEnd();
			else
				wf->putChar(' ');
			wf->putStr("outputclass=\"");
			wf->putStr(IniFile->StrRight());
			wf->putChar('"');
		}
	}
}



// DocBook book file processing

char *HXMwr::DocBookRoot = NULL;
bool HXMwr::WriteBookFile = false;
char *HXMwr::BookFileName = NULL;
char *HXMwr::BookFileTitle = NULL;

void
HXMwr::WriteDocBookFile(DCrfile *rf, char *destname, char *buf)
{
	if (!BookFileName || !*BookFileName)
		BookFileName = HTMwr::ReplaceExt(destname, ".xml");
	if (!BookFileTitle || !*BookFileTitle)
		BookFileTitle = HTMwr::ReplaceExt(destname);

	HTMwfile *wf = new HTMwfile(BookFileName);
  if (wf->FErr() != fok)
    wf->Err();
	long erdiv = wf->NewDiv();
	wf->SelectDiv(0);

	wf->putXML(HTMwr::XMLEncoding, HTMwr::XMLVer);
	wf->putText('<');
	wf->putStr("!DOCTYPE ");
	wf->putStr(HTMwr::XMLRoot);
	wf->putStr(" PUBLIC ");
	wf->putStr(HTMwr::PrologDType);
	wf->putEnd();
	wf->putStr(HTMwr::PrologDTD);
	wf->putStr(" [");
	wf->putEnd();

	//  entity definitions
	while (rf->getLine(buf, TextBufMax))
		ProcDocBookEnt(buf, wf, erdiv);

	wf->putStr("]>");
	wf->putEnd();
	wf->startBlock(HTMwr::XMLRoot);
	wf->strAttr(HTMwr::XHLangAttr, HTMwr::XhtmlLang);
	wf->endElem(true);
	wf->putEnd();

	if (HTMwr::GeneratorTag == 'C') {
		wf->startComment();
		wf->putStr("generated by ");
		wf->putStr(HTMwr::FilterVer);
		wf->endComment();
		wf->putEnd();
	}

	wf->writeTextBlock("title", BookFileTitle);

	// entity references
	wf->WriteDiv(erdiv);
	wf->DeleteDiv(erdiv);
	wf->SelectDiv(0);

	wf->endBlock(HTMwr::XMLRoot);
	wf->putEnd();
  wf->CloseFile();
}

void
HXMwr::ProcDocBookEnt(char *buf, HTMwfile *wf, long erdiv)
{
	char *fname = HTMwr::ReplaceExt(buf, HTMwr::XrefFileSuffix);
	char *fileid = HTMwr::GetFileID(buf);

	// <!ENTITY fileid SYSTEM "filename.ent">
	wf->putStr("<!ENTITY ");
	wf->putStr(fileid);
	wf->putStr(" SYSTEM \"");
	wf->putStr(fname);
	wf->putStr("\">");
	wf->putEnd();

	// &fileid;
	wf->SelectDiv(erdiv);
	wf->putChar('&');
	wf->putStr(fileid);
	wf->putChar(';');
	wf->putEnd();
	wf->SelectDiv(0);
}


// end of dwhtmdm.cpp

